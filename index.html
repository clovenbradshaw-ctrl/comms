<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="theme-color" content="#000000">
  <meta name="description" content="Secure P2P chat with end-to-end encryption">
  
  <!-- PWA Meta Tags -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Secure Chat">
  
  <title>Secure P2P Chat</title>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-primary: #000000;
      --bg-secondary: #1a1a1a;
      --bg-tertiary: #2a2a2a;
      --text-primary: #ffffff;
      --text-secondary: #a0a0a0;
      --accent: #0066ff;
      --accent-hover: #0052cc;
      --success: #00d68f;
      --error: #ff3b30;
      --warning: #ffaa00;
      --message-bg: #1a1a1a;
      --message-me: #0066ff;
      --border: #333;
      --shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    /* Animated Background */
    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 50%, rgba(0, 102, 255, 0.2) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(255, 0, 128, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 40% 20%, rgba(0, 255, 136, 0.1) 0%, transparent 50%);
      animation: backgroundShift 20s ease-in-out infinite;
      pointer-events: none;
    }

    @keyframes backgroundShift {
      0%, 100% { opacity: 0.5; transform: scale(1) rotate(0deg); }
      50% { opacity: 1; transform: scale(1.1) rotate(10deg); }
    }

    .app {
      width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
      position: relative;
      z-index: 1;
      max-width: 100%;
      margin: 0 auto;
    }

    /* Header */
    .header {
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      padding: 1rem 1.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border);
      min-height: 60px;
    }

    .logo {
      font-size: 1.25rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      letter-spacing: -0.5px;
    }

    .logo-icon {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, #0066ff, #00d68f);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
    }

    .connection-badge {
      padding: 0.5rem 1rem;
      background: var(--bg-tertiary);
      border-radius: 100px;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: all 0.3s ease;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      background: var(--text-secondary);
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    .status-dot.connected {
      background: var(--success);
    }

    .status-dot.connecting {
      background: var(--warning);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }

    /* Screens */
    .screen {
      display: none;
      flex: 1;
      position: relative;
    }

    .screen.active {
      display: flex;
      flex-direction: column;
    }

    /* Welcome Screen */
    .welcome {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 2rem;
      text-align: center;
    }

    .welcome-card {
      background: rgba(26, 26, 26, 0.6);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--border);
      border-radius: 24px;
      padding: 3rem;
      max-width: 500px;
      width: 100%;
      box-shadow: var(--shadow);
      animation: fadeInUp 0.5s ease;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .welcome h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 1rem;
      background: linear-gradient(135deg, #fff, #a0a0a0);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .welcome p {
      color: var(--text-secondary);
      margin-bottom: 2rem;
      line-height: 1.6;
    }

    .features {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1rem;
      margin: 2rem 0;
    }

    .feature {
      padding: 1rem;
      background: var(--bg-tertiary);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }

    .feature-icon {
      font-size: 1.5rem;
    }

    .feature-text {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .action-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-top: 2rem;
    }

    .btn {
      padding: 1rem 2rem;
      border: none;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      outline: none;
      -webkit-tap-highlight-color: transparent;
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-primary:hover {
      background: var(--accent-hover);
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(0, 102, 255, 0.3);
    }

    .btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: #333;
      transform: translateY(-2px);
    }

    /* Room Setup */
    .setup-screen {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 2rem;
    }

    .setup-card {
      background: rgba(26, 26, 26, 0.6);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--border);
      border-radius: 24px;
      padding: 3rem;
      max-width: 500px;
      width: 100%;
      box-shadow: var(--shadow);
      animation: fadeInUp 0.5s ease;
    }

    .room-code-display {
      background: var(--bg-primary);
      border: 2px dashed var(--accent);
      border-radius: 16px;
      padding: 1.5rem;
      margin: 1.5rem 0;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 1.5rem;
      letter-spacing: 0.3rem;
      text-align: center;
      color: var(--accent);
      user-select: all;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .room-code-display:hover {
      background: rgba(0, 102, 255, 0.1);
      transform: scale(1.02);
    }

    .input-group {
      margin: 1.5rem 0;
    }

    .input-label {
      display: block;
      margin-bottom: 0.5rem;
      font-size: 0.875rem;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .input-field {
      width: 100%;
      padding: 1rem;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-primary);
      font-size: 1rem;
      transition: all 0.3s ease;
      outline: none;
    }

    .input-field:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);
    }

    .share-section {
      margin-top: 2rem;
      padding: 1.5rem;
      background: rgba(0, 102, 255, 0.1);
      border-radius: 12px;
      border: 1px solid rgba(0, 102, 255, 0.3);
    }

    .share-link {
      background: var(--bg-primary);
      padding: 1rem;
      border-radius: 8px;
      word-break: break-all;
      font-size: 0.75rem;
      font-family: monospace;
      cursor: pointer;
      margin: 0.75rem 0;
    }

    .share-link:hover {
      background: var(--bg-secondary);
    }

    /* Chat Interface */
    .chat-container {
      height: 100%;
      display: flex;
      flex-direction: column;
      background: var(--bg-primary);
    }

    .chat-header {
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .view-toggles {
      display: flex;
      gap: 0.75rem;
      align-items: center;
      margin-right: auto;
      margin-left: 1.5rem;
    }

    .toggle-btn {
      padding: 0.5rem 1rem;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.85rem;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    .toggle-btn:hover {
      background: #333;
    }

    .toggle-btn.active {
      background: var(--accent);
      border-color: var(--accent);
    }

    .waiting-banner {
      display: none;
      margin: 1.5rem;
      margin-bottom: 0;
      padding: 1.25rem;
      background: rgba(0, 102, 255, 0.08);
      border: 1px solid rgba(0, 102, 255, 0.25);
      border-radius: 16px;
      gap: 1rem;
      align-items: flex-start;
    }

    .waiting-banner.active {
      display: flex;
    }

    .waiting-icon {
      font-size: 1.5rem;
      line-height: 1;
    }

    .waiting-details {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      flex: 1;
    }

    .waiting-title {
      font-weight: 600;
      font-size: 1rem;
    }

    .waiting-subtitle {
      color: var(--text-secondary);
      font-size: 0.875rem;
      line-height: 1.4;
    }

    .waiting-link-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
    }

    .chat-share-link {
      flex: 1;
      min-width: 200px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 0.75rem 1rem;
      font-family: monospace;
      font-size: 0.8rem;
      word-break: break-all;
      cursor: pointer;
      transition: background 0.3s ease, border-color 0.3s ease;
    }

    .chat-share-link:hover {
      background: var(--bg-secondary);
      border-color: var(--accent);
    }

    #chatCopyLink:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .chat-room-info {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .room-badge {
      padding: 0.5rem 1rem;
      background: var(--bg-tertiary);
      border-radius: 100px;
      font-size: 0.875rem;
      font-family: monospace;
      color: var(--accent);
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      scroll-behavior: smooth;
    }

    .chat-messages::-webkit-scrollbar {
      width: 8px;
    }

    .chat-messages::-webkit-scrollbar-track {
      background: transparent;
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: var(--bg-tertiary);
      border-radius: 100px;
    }

    .message {
      display: flex;
      align-items: flex-end;
      gap: 0.5rem;
      animation: messageIn 0.3s ease;
    }

    @keyframes messageIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message.me {
      flex-direction: row-reverse;
    }

    .message-content {
      max-width: 70%;
      padding: 0.875rem 1.25rem;
      background: var(--message-bg);
      border-radius: 18px 18px 18px 4px;
      word-wrap: break-word;
      position: relative;
    }

    .message.me .message-content {
      background: var(--message-me);
      border-radius: 18px 18px 4px 18px;
    }

    .message-text {
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .message-time {
      font-size: 0.7rem;
      opacity: 0.6;
      margin-top: 0.25rem;
    }

    .system-message {
      text-align: center;
      padding: 0.5rem 1rem;
      margin: 0.5rem auto;
      background: var(--bg-tertiary);
      border-radius: 100px;
      font-size: 0.875rem;
      color: var(--text-secondary);
      max-width: fit-content;
      animation: messageIn 0.3s ease;
    }

    .message.encrypted-view .message-content {
      font-family: 'SFMono-Regular', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
      background: rgba(0, 102, 255, 0.12);
      border: 1px solid rgba(0, 102, 255, 0.3);
      color: var(--text-primary);
    }

    .encrypted-data {
      font-size: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .data-label {
      color: var(--accent);
      font-weight: 600;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .data-hex {
      word-break: break-all;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .data-info {
      color: var(--text-secondary);
      opacity: 0.7;
      margin-top: 0.25rem;
      font-size: 0.7rem;
    }

    .chat-input-container {
      padding: 1.5rem;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-top: 1px solid var(--border);
    }

    .chat-input-wrapper {
      display: flex;
      gap: 1rem;
      align-items: center;
      max-width: 1200px;
      margin: 0 auto;
    }

    .chat-input {
      flex: 1;
      padding: 1rem 1.5rem;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 100px;
      color: var(--text-primary);
      font-size: 0.95rem;
      outline: none;
      transition: all 0.3s ease;
    }

    .chat-input:focus {
      border-color: var(--accent);
      background: var(--bg-secondary);
    }

    .chat-input::placeholder {
      color: var(--text-secondary);
    }

    .send-btn {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .send-btn:hover:not(:disabled) {
      background: var(--accent-hover);
      transform: scale(1.1);
    }

    .send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .schema-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      z-index: 1000;
      overflow-y: auto;
      padding: 2rem;
    }

    .schema-content {
      max-width: 960px;
      margin: 0 auto;
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 2rem;
      box-shadow: 0 25px 60px rgba(0, 0, 0, 0.6);
    }

    .schema-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--border);
    }

    .schema-header button {
      border: none;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border-radius: 8px;
      padding: 0.4rem 0.75rem;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .schema-header button:hover {
      background: #333;
    }

    .schema-section {
      margin: 2rem 0;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .schema-section h3 {
      color: var(--accent);
      font-size: 1.1rem;
    }

    .schema-code {
      background: var(--bg-primary);
      padding: 1rem;
      border-radius: 12px;
      overflow-x: auto;
      border: 1px solid var(--border);
    }

    .schema-code pre {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.85rem;
      line-height: 1.6;
    }

    .schema-tabs {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .tab-btn {
      padding: 0.5rem 0.85rem;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--bg-tertiary);
      color: var(--text-primary);
      cursor: pointer;
      font-size: 0.8rem;
      transition: all 0.3s ease;
    }

    .tab-btn.active {
      background: var(--accent);
      border-color: var(--accent);
    }

    .tab-content {
      display: none;
      background: var(--bg-primary);
      padding: 1rem;
      border-radius: 12px;
      border: 1px solid var(--border);
      max-height: 360px;
      overflow-y: auto;
      font-size: 0.8rem;
    }

    .tab-content.active {
      display: block;
    }

    .events-timeline {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .event-item {
      padding: 0.75rem;
      background: var(--bg-tertiary);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .event-op {
      font-weight: 600;
      color: var(--accent);
      margin-bottom: 0.25rem;
      font-size: 0.85rem;
    }

    .event-details {
      color: var(--text-secondary);
      font-size: 0.75rem;
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
      margin-bottom: 0.35rem;
    }

    .event-payload {
      font-family: 'SFMono-Regular', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
      font-size: 0.75rem;
      color: var(--text-secondary);
      word-break: break-all;
      white-space: pre-wrap;
    }

    .storage-diagram {
      display: grid;
      gap: 1rem;
    }

    .storage-layer {
      background: var(--bg-primary);
      border-radius: 12px;
      border-left: 3px solid var(--accent);
      padding: 1rem 1.25rem;
      line-height: 1.5;
    }

    /* Room History */
    .room-history {
      margin-top: 2rem;
      padding-top: 2rem;
      border-top: 1px solid var(--border);
    }

    .history-title {
      font-size: 0.875rem;
      color: var(--text-secondary);
      margin-bottom: 1rem;
      font-weight: 600;
    }

    .history-items {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .history-item {
      padding: 1rem;
      background: var(--bg-tertiary);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .history-item:hover {
      background: #333;
      transform: translateX(5px);
    }

    .history-room {
      font-family: monospace;
      color: var(--accent);
      font-size: 0.875rem;
    }

    .history-time {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .welcome-card, .setup-card {
        padding: 2rem 1.5rem;
      }

      .welcome h1 {
        font-size: 2rem;
      }

      .features {
        grid-template-columns: 1fr;
      }

      .action-buttons {
        grid-template-columns: 1fr;
      }

      .message-content {
        max-width: 85%;
      }

      .room-code-display {
        font-size: 1.2rem;
        letter-spacing: 0.2rem;
      }

      .chat-header {
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      .view-toggles {
        order: 3;
        width: 100%;
        margin: 0;
        justify-content: flex-start;
        gap: 0.5rem;
      }
    }

    @media (max-width: 480px) {
      .header {
        padding: 1rem;
      }

      .logo-text {
        display: none;
      }

      .chat-messages {
        padding: 1rem;
      }

      .chat-input-container {
        padding: 1rem;
      }

      .waiting-banner {
        margin: 1rem;
      }

      .waiting-link-row {
        flex-direction: column;
        align-items: stretch;
      }

      #chatCopyLink {
        width: 100%;
      }

      .view-toggles {
        flex-direction: column;
        align-items: stretch;
      }

      .toggle-btn {
        width: 100%;
        justify-content: center;
      }
    }

    /* iOS Safe Areas */
    @supports (padding-top: env(safe-area-inset-top)) {
      .header {
        padding-top: calc(1rem + env(safe-area-inset-top));
      }

      .chat-input-container {
        padding-bottom: calc(1.5rem + env(safe-area-inset-bottom));
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- Header -->
    <div class="header">
      <div class="logo">
        <div class="logo-icon">🔐</div>
        <span class="logo-text">Secure Chat</span>
      </div>
      <div class="connection-badge">
        <span class="status-dot" id="statusDot"></span>
        <span id="statusText">Disconnected</span>
      </div>
    </div>

    <!-- Welcome Screen -->
    <div id="welcomeScreen" class="screen active">
      <div class="welcome">
        <div class="welcome-card">
          <h1>Secure P2P Chat</h1>
          <p>End-to-end encrypted messaging with no servers. Your messages stay on your device.</p>

          <div class="features">
            <div class="feature">
              <div class="feature-icon">🔐</div>
              <div class="feature-text">E2E Encrypted</div>
            </div>
            <div class="feature">
              <div class="feature-icon">🌐</div>
              <div class="feature-text">No Servers</div>
            </div>
            <div class="feature">
              <div class="feature-icon">💾</div>
              <div class="feature-text">Local Storage</div>
            </div>
          </div>

          <div class="action-buttons">
            <button class="btn btn-primary" onclick="app.showHost()">
              <span>🏠</span>
              <span>Create Room</span>
            </button>
            <button class="btn btn-secondary" onclick="app.showJoin()">
              <span>🔗</span>
              <span>Join Room</span>
            </button>
          </div>

          <!-- Room History -->
          <div id="roomHistory" class="room-history" style="display:none;">
            <div class="history-title">Recent Rooms</div>
            <div id="historyItems" class="history-items"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Host Setup Screen -->
    <div id="hostScreen" class="screen">
      <div class="setup-screen">
        <div class="setup-card">
          <h2>Create Secure Room</h2>
          <p style="color: var(--text-secondary); text-align: center; margin-bottom: 1rem;">Share this room code with someone you trust</p>
          
          <div class="room-code-display" id="roomCode" onclick="app.copyRoomCode()">
            Loading...
          </div>
          
          <div class="input-group">
            <label class="input-label">Set Encryption Password</label>
            <input type="password" id="hostPassword" class="input-field" placeholder="Choose a strong password">
          </div>
          
          <button class="btn btn-primary" style="width: 100%;" onclick="app.startHost()">
            Start Secure Room
          </button>
          
          <div id="shareSection" class="share-section" style="display: none;">
            <p style="font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 0.75rem;">📤 Share this link with others:</p>
            <div class="share-link" id="shareLink" onclick="app.copyShareLink()">
              Generating link...
            </div>
            <button class="btn btn-primary" style="width: 100%;" onclick="app.copyShareLink()">📋 Copy Link</button>
          </div>
          
          <button class="btn btn-secondary" style="width: 100%; margin-top: 1rem;" onclick="app.showWelcome()">
            Back
          </button>
        </div>
      </div>
    </div>

    <!-- Join Setup Screen -->
    <div id="joinScreen" class="screen">
      <div class="setup-screen">
        <div class="setup-card">
          <h2>Join Secure Room</h2>
          <p style="color: var(--text-secondary); text-align: center; margin-bottom: 1rem;">Enter the room details shared with you</p>
          
          <div class="input-group">
            <label class="input-label">Room Code</label>
            <input type="text" id="joinCode" class="input-field" placeholder="xxx-xxx-xxx">
          </div>
          
          <div class="input-group">
            <label class="input-label">Encryption Password</label>
            <input type="password" id="joinPassword" class="input-field" placeholder="Enter shared password">
            <div id="passwordHint" style="color: var(--accent); font-size: 0.875rem; margin-top: 0.5rem; display: none;"></div>
          </div>
          
          <button class="btn btn-primary" style="width: 100%;" onclick="app.startJoin()">
            Join Room
          </button>
          
          <button class="btn btn-secondary" style="width: 100%; margin-top: 1rem;" onclick="app.showWelcome()">
            Back
          </button>
        </div>
      </div>
    </div>

    <!-- Chat Screen -->
    <div id="chatScreen" class="screen">
      <div class="chat-container">
        <div class="chat-header">
          <div class="chat-room-info">
            <span>🔐</span>
            <div class="room-badge" id="currentRoom">xxx-xxx-xxx</div>
          </div>
          <div class="view-toggles">
            <button id="encryptedToggle" class="toggle-btn" onclick="app.toggleEncryptedView()">
              <span>🔍</span>
              Encrypted View
            </button>
            <button id="schemaToggle" class="toggle-btn" onclick="app.showSchemaView()">
              <span>📊</span>
              Data Schema
            </button>
          </div>
          <button class="btn btn-secondary" style="padding: 0.5rem 1rem;" onclick="app.disconnect()">
            Leave
          </button>
        </div>

        <div id="waitingBanner" class="waiting-banner">
          <div class="waiting-icon">⏳</div>
          <div class="waiting-details">
            <div class="waiting-title">Waiting for your guest</div>
            <div id="waitingMessage" class="waiting-subtitle">Share the invite link below to bring someone into this secure room.</div>
            <div class="waiting-link-row">
              <div id="chatShareLink" class="chat-share-link" onclick="app.copyShareLink('chatShareLink')">
                Generating link...
              </div>
              <button id="chatCopyLink" class="btn btn-secondary" onclick="app.copyShareLink('chatShareLink')" disabled>
                📋 Copy Link
              </button>
            </div>
          </div>
        </div>

        <div id="chatMessages" class="chat-messages">
          <!-- Messages will appear here -->
        </div>

        <div class="chat-input-container">
          <div class="chat-input-wrapper">
            <input type="text" id="messageInput" class="chat-input" placeholder="Type a secure message...">
            <button id="sendBtn" class="send-btn">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="22" y1="2" x2="11" y2="13"></line>
                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
              </svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Load PeerJS -->
  <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>

  <script>
    const EVENT_SEMVER = '1.0.0';
    const SNAPSHOT_THRESHOLD = 200;

    function generateId(prefix = '') {
      const core = (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function')
        ? crypto.randomUUID()
        : `${Date.now().toString(36)}-${Math.random().toString(36).slice(2)}`;
      return prefix ? `${prefix}${core}` : core;
    }

    function makeEvent(op, payload, actor, refs = []) {
      return {
        id: generateId('evt-'),
        op,
        payload,
        actor: actor || 'system',
        refs,
        at: Date.now(),
        semver: EVENT_SEMVER
      };
    }

    class ChatState {
      constructor() {
        this.rooms = new Map();
        this.messages = new Map();
        this.byRoom = new Map();
        this.reactions = new Map();
      }
    }

    function ensureRoom(state, roomId, defaults = {}) {
      if (!state.rooms.has(roomId)) {
        state.rooms.set(roomId, {
          id: roomId,
          title: defaults.title || roomId,
          members: new Set(defaults.members || []),
          pinned: new Set(defaults.pinned || []),
          lastActive: defaults.lastActive ?? 0,
          createdAt: defaults.createdAt ?? defaults.lastActive ?? 0
        });
      }
      if (!state.byRoom.has(roomId)) {
        state.byRoom.set(roomId, Array.isArray(defaults.messageOrder) ? [...defaults.messageOrder] : []);
      }
      const room = state.rooms.get(roomId);
      if (defaults.title && !room.title) {
        room.title = defaults.title;
      }
      if (typeof defaults.lastActive === 'number' && !room.lastActive) {
        room.lastActive = defaults.lastActive;
      }
      if (typeof defaults.createdAt === 'number' && !room.createdAt) {
        room.createdAt = defaults.createdAt;
      }
      return room;
    }

    function reduce(state, event) {
      const type = event?.op;
      const payload = event?.payload || {};

      switch (type) {
        case 'RoomCreated': {
          const { roomId, title } = payload;
          const room = ensureRoom(state, roomId, { title, createdAt: event.at, lastActive: event.at });
          room.title = title;
          room.createdAt = event.at;
          room.lastActive = event.at;
          break;
        }
        case 'UserJoinedRoom': {
          const { roomId, userId } = payload;
          const room = ensureRoom(state, roomId);
          room.members.add(userId);
          room.lastActive = Math.max(room.lastActive || 0, event.at || 0);
          break;
        }
        case 'UserLeftRoom': {
          const { roomId, userId } = payload;
          const room = ensureRoom(state, roomId);
          room.members.delete(userId);
          room.lastActive = Math.max(room.lastActive || 0, event.at || 0);
          break;
        }
        case 'MessagePosted': {
          const { roomId, messageId, userId, text, type: messageType } = payload;
          const room = ensureRoom(state, roomId);
          const message = {
            id: messageId,
            roomId,
            userId,
            text,
            type: messageType || 'them',
            at: event.at,
            editedAt: undefined,
            redacted: false
          };
          state.messages.set(messageId, message);
          const order = state.byRoom.get(roomId) || [];
          order.push(messageId);
          state.byRoom.set(roomId, order);
          room.lastActive = Math.max(room.lastActive || 0, event.at || 0);
          break;
        }
        case 'MessageEdited': {
          const { messageId, newText } = payload;
          const message = state.messages.get(messageId);
          if (message) {
            message.text = newText;
            message.editedAt = event.at;
            const room = ensureRoom(state, message.roomId);
            room.lastActive = Math.max(room.lastActive || 0, event.at || 0);
          }
          break;
        }
        case 'MessageRedacted': {
          const { messageId } = payload;
          const message = state.messages.get(messageId);
          if (message) {
            message.redacted = true;
            const room = ensureRoom(state, message.roomId);
            room.lastActive = Math.max(room.lastActive || 0, event.at || 0);
          }
          break;
        }
        case 'ReactionAdded': {
          const { messageId, userId, emoji } = payload;
          const emojiMap = state.reactions.get(messageId) || new Map();
          const users = emojiMap.get(emoji) || new Set();
          users.add(userId);
          emojiMap.set(emoji, users);
          state.reactions.set(messageId, emojiMap);
          break;
        }
        case 'ReactionRemoved': {
          const { messageId, userId, emoji } = payload;
          const emojiMap = state.reactions.get(messageId);
          if (emojiMap?.has(emoji)) {
            const users = emojiMap.get(emoji);
            users.delete(userId);
            if (users.size === 0) {
              emojiMap.delete(emoji);
            }
            if (emojiMap.size === 0) {
              state.reactions.delete(messageId);
            }
          }
          break;
        }
        case 'MessagePinned': {
          const { roomId, messageId } = payload;
          const room = ensureRoom(state, roomId);
          room.pinned.add(messageId);
          room.lastActive = Math.max(room.lastActive || 0, event.at || 0);
          break;
        }
        case 'MessageUnpinned': {
          const { roomId, messageId } = payload;
          const room = ensureRoom(state, roomId);
          room.pinned.delete(messageId);
          room.lastActive = Math.max(room.lastActive || 0, event.at || 0);
          break;
        }
        default:
          break;
      }
    }

    function serializeState(state) {
      return {
        rooms: Array.from(state.rooms.values()).map(room => ({
          id: room.id,
          title: room.title,
          members: Array.from(room.members),
          pinned: Array.from(room.pinned),
          lastActive: room.lastActive || 0,
          createdAt: room.createdAt || 0
        })),
        messages: Array.from(state.messages.values()).map(message => ({ ...message })),
        byRoom: Array.from(state.byRoom.entries()).map(([roomId, ids]) => [roomId, [...ids]]),
        reactions: Array.from(state.reactions.entries()).map(([messageId, emojiMap]) => ({
          messageId,
          emojis: Array.from(emojiMap.entries()).map(([emoji, users]) => ({
            emoji,
            users: Array.from(users)
          }))
        }))
      };
    }

    function reviveState(raw) {
      const state = new ChatState();
      if (!raw) {
        return state;
      }

      (raw.rooms || []).forEach(roomData => {
        state.rooms.set(roomData.id, {
          id: roomData.id,
          title: roomData.title,
          members: new Set(roomData.members || []),
          pinned: new Set(roomData.pinned || []),
          lastActive: roomData.lastActive || 0,
          createdAt: roomData.createdAt || 0
        });
      });

      (raw.byRoom || []).forEach(([roomId, ids]) => {
        ensureRoom(state, roomId);
        state.byRoom.set(roomId, Array.isArray(ids) ? [...ids] : []);
      });

      (raw.messages || []).forEach(message => {
        state.messages.set(message.id, { ...message });
        ensureRoom(state, message.roomId);
      });

      (raw.reactions || []).forEach(entry => {
        const emojiMap = new Map();
        (entry.emojis || []).forEach(({ emoji, users }) => {
          emojiMap.set(emoji, new Set(users || []));
        });
        state.reactions.set(entry.messageId, emojiMap);
      });

      return state;
    }

    class StorageManager {
      constructor() {
        this.state = new ChatState();
        this.db = null;
        this.useMemory = false;
        this.eventsBuffer = [];
        this.snapshotFrequency = SNAPSHOT_THRESHOLD;
        this.appliedSinceSnapshot = 0;
        this.ready = this.init();
      }

      async init() {
        if (!('indexedDB' in window)) {
          this.useMemory = true;
          return;
        }

        try {
          this.db = await this.openDB();
          await this.rehydrate();
        } catch (error) {
          console.warn('IndexedDB unavailable, falling back to in-memory storage.', error);
          this.useMemory = true;
          this.db = null;
        }
      }

      openDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open('secure-chat-eventlog', 1);

          request.onupgradeneeded = (event) => {
            const db = event.target.result;

            if (!db.objectStoreNames.contains('events')) {
              const events = db.createObjectStore('events', { keyPath: 'id' });
              events.createIndex('at', 'at');
              events.createIndex('actor', 'actor');
              events.createIndex('op', 'op');
              events.createIndex('refs', 'refs', { multiEntry: true });
            }

            if (!db.objectStoreNames.contains('snapshots')) {
              const snapshots = db.createObjectStore('snapshots', { keyPath: 'id' });
              snapshots.createIndex('at', 'at');
            }

            if (!db.objectStoreNames.contains('blobs')) {
              db.createObjectStore('blobs', { keyPath: 'id' });
            }
          };

          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }

      async rehydrate() {
        if (this.useMemory || !this.db) {
          return;
        }

        let snapshot = null;
        try {
          snapshot = await new Promise((resolve) => {
            const tx = this.db.transaction('snapshots', 'readonly');
            const store = tx.objectStore('snapshots');
            const index = store.index('at');
            const request = index.openCursor(null, 'prev');
            request.onsuccess = (event) => {
              const cursor = event.target.result;
              resolve(cursor ? cursor.value : null);
            };
            request.onerror = () => resolve(null);
          });
        } catch (error) {
          console.warn('Failed to read snapshot.', error);
        }

        if (snapshot?.state) {
          this.state = reviveState(snapshot.state);
        } else {
          this.state = new ChatState();
        }

        const after = snapshot?.at ?? 0;
        let events = [];
        try {
          events = await this.loadEventsAfter(after);
        } catch (error) {
          console.warn('Failed to load events.', error);
          events = [];
        }

        events.sort((a, b) => (a.at || 0) - (b.at || 0));
        for (const event of events) {
          await this.apply(event, { persist: false });
        }

        this.appliedSinceSnapshot = events.length % this.snapshotFrequency;
      }

      loadEventsAfter(at) {
        if (this.useMemory) {
          return Promise.resolve(this.eventsBuffer.filter(event => (event.at || 0) > at));
        }

        if (!this.db) {
          return Promise.resolve([]);
        }

        return new Promise((resolve) => {
          const tx = this.db.transaction('events', 'readonly');
          const index = tx.objectStore('events').index('at');
          const range = at ? IDBKeyRange.lowerBound(at, true) : null;
          const request = index.getAll(range);
          request.onsuccess = () => resolve(request.result || []);
          request.onerror = () => resolve([]);
        });
      }

      async apply(event, { persist = true } = {}) {
        if (!event) {
          return;
        }

        if (persist && !this.useMemory && this.db) {
          await new Promise((resolve, reject) => {
            const tx = this.db.transaction('events', 'readwrite');
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
            tx.objectStore('events').put(event);
          });
        } else if (persist && this.useMemory) {
          this.eventsBuffer.push(event);
        }

        reduce(this.state, event);

        if (persist && !this.useMemory) {
          this.appliedSinceSnapshot += 1;
          if (this.appliedSinceSnapshot >= this.snapshotFrequency) {
            await this.snapshot();
          }
        }
      }

      async snapshot() {
        if (this.useMemory || !this.db) {
          return;
        }

        const snapshot = {
          id: generateId('snap-'),
          at: Date.now(),
          state: serializeState(this.state)
        };

        await new Promise((resolve, reject) => {
          const tx = this.db.transaction('snapshots', 'readwrite');
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
          tx.objectStore('snapshots').put(snapshot);
        });

        this.appliedSinceSnapshot = 0;
      }

      async saveRoom(roomId, { actorId = 'local', title = '' } = {}) {
        if (!roomId) {
          return;
        }

        await this.ready;
        const roomTitle = title || roomId;

        if (!this.state.rooms.has(roomId)) {
          await this.apply(makeEvent('RoomCreated', { roomId, title: roomTitle }, actorId, [`room:${roomId}`]));
        }

        await this.apply(makeEvent('UserJoinedRoom', { roomId, userId: actorId }, actorId, [`room:${roomId}`, `user:${actorId}`]));
      }

      async leaveRoom(roomId, { actorId = 'local' } = {}) {
        if (!roomId) {
          return;
        }

        await this.ready;
        await this.apply(makeEvent('UserLeftRoom', { roomId, userId: actorId }, actorId, [`room:${roomId}`, `user:${actorId}`]));
      }

      async recordMessage({ roomId, text, type = 'them', actorId = 'system', userId, messageId }) {
        if (!roomId || !text) {
          return null;
        }

        await this.ready;
        const id = messageId || generateId('msg-');
        const event = makeEvent(
          'MessagePosted',
          { roomId, messageId: id, userId: userId || actorId, text, type },
          actorId,
          [`room:${roomId}`, `msg:${id}`]
        );

        await this.apply(event);
        return this.state.messages.get(id);
      }

      async getRooms() {
        await this.ready;

        const rooms = Array.from(this.state.rooms.values()).map(room => ({
          id: room.id,
          title: room.title,
          time: room.lastActive || room.createdAt || 0
        }));

        rooms.sort((a, b) => (b.time || 0) - (a.time || 0));
        return rooms.slice(0, 5);
      }

      async getMessages(roomId) {
        await this.ready;

        if (!roomId) {
          return [];
        }

        const ids = this.state.byRoom.get(roomId) || [];
        const messages = [];

        for (const id of ids) {
          const message = this.state.messages.get(id);
          if (!message || message.redacted) {
            continue;
          }

          messages.push({
            id: message.id,
            content: message.text,
            type: message.type || 'them',
            at: message.at,
            editedAt: message.editedAt
          });
        }

        return messages;
      }
    }

    class SecureChat {
      constructor() {
        this.peer = null;
        this.conn = null;
        this.roomId = null;
        this.cryptoKey = null;
        this.isHost = false;
        this.currentShareLink = '';
        this.localUserId = generateId('user-');
        this.remoteUserId = null;
        this.showEncrypted = false;
        this.messageLog = [];
        this.lastEncryptedHex = '';

        this.initStorage();
        this.loadRoomHistory();
        this.checkForSharedLink();
        this.initEventListeners();
        this.updateStatus('Disconnected', '');
        this.setWaitingBanner(false, '');
      }

      initEventListeners() {
        // Enter key to send
        document.getElementById('messageInput').addEventListener('keypress', (e) => {
          if (e.key === 'Enter') this.sendMessage();
        });
        
        // Send button
        document.getElementById('sendBtn').addEventListener('click', () => this.sendMessage());
      }

      // Check URL parameters for shared link
      checkForSharedLink() {
        const params = new URLSearchParams(window.location.search);
        const room = params.get('room');
        const key = params.get('key');
        
        if (room && key) {
          document.getElementById('joinCode').value = room;
          
          try {
            const decoded = atob(key);
            const hint = document.getElementById('passwordHint');
            hint.textContent = `Password hint: ${decoded}`;
            hint.style.display = 'block';
          } catch(e) {
            // Invalid key
          }
          
          this.showJoin();
          window.history.replaceState({}, document.title, window.location.pathname);
        }
      }

      // Generate shareable link
      generateShareLink(roomId, password) {
        const baseUrl = window.location.origin + window.location.pathname;
        const hint = password.length > 2 
          ? `${password[0]}***${password[password.length-1]} (${password.length} chars)`
          : `${password.length} characters`;
        const encodedHint = btoa(hint);
        
        return `${baseUrl}?room=${encodeURIComponent(roomId)}&key=${encodeURIComponent(encodedHint)}`;
      }

      copyShareLink(targetId = 'shareLink') {
        const elem = document.getElementById(targetId);
        if (!elem) {
          return;
        }

        const storedLink = elem.dataset?.link;
        const link = storedLink || elem.textContent;

        if (!link || link === 'Generating link...') {
          return;
        }

        navigator.clipboard.writeText(link).then(() => {
          const original = elem.textContent;
          elem.textContent = '✅ Link copied!';
          setTimeout(() => {
            elem.textContent = elem.dataset?.link || original;
          }, 2000);
        });
      }

      setWaitingBanner(visible, link, message) {
        const banner = document.getElementById('waitingBanner');
        const linkEl = document.getElementById('chatShareLink');
        const messageEl = document.getElementById('waitingMessage');
        const copyBtn = document.getElementById('chatCopyLink');

        if (!banner || !linkEl) {
          return;
        }

        if (link !== undefined) {
          if (link) {
            linkEl.textContent = link;
            linkEl.dataset.link = link;
          } else {
            linkEl.textContent = 'Generating link...';
            delete linkEl.dataset.link;
          }
        }

        if (message && messageEl) {
          messageEl.textContent = message;
        }

        const hasLink = Boolean(linkEl.dataset.link);

        if (visible && hasLink) {
          banner.classList.add('active');
          if (copyBtn) {
            copyBtn.disabled = false;
          }
        } else {
          banner.classList.remove('active');
          if (copyBtn) {
            copyBtn.disabled = true;
          }
        }
      }

      // Screen Navigation
      showScreen(screenId) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(screenId).classList.add('active');
      }

      showWelcome() {
        this.showScreen('welcomeScreen');
        this.loadRoomHistory();
      }

      showHost() {
        this.roomId = this.generateRoomId();
        document.getElementById('roomCode').textContent = this.roomId;
        document.getElementById('shareSection').style.display = 'none';
        const shareLinkEl = document.getElementById('shareLink');
        if (shareLinkEl) {
          shareLinkEl.textContent = 'Generating link...';
          delete shareLinkEl.dataset.link;
        }
        this.currentShareLink = '';
        this.setWaitingBanner(false, '');
        this.showScreen('hostScreen');
      }

      showJoin() {
        this.showScreen('joinScreen');
      }

      showChat() {
        console.log('Showing chat interface for room:', this.roomId);

        document.getElementById('welcomeScreen').classList.remove('active');
        document.getElementById('hostScreen').classList.remove('active');
        document.getElementById('joinScreen').classList.remove('active');
        document.getElementById('chatScreen').classList.add('active');

        document.getElementById('currentRoom').textContent = this.roomId;

        if (this.isHost && this.currentShareLink) {
          this.setWaitingBanner(true, this.currentShareLink);
        } else {
          this.setWaitingBanner(false);
        }

        setTimeout(() => {
          document.getElementById('messageInput').focus();
        }, 100);
      }

      // Storage
      initStorage() {
        this.storage = new StorageManager();
        if (this.storage?.ready) {
          this.storage.ready.then(() => this.loadRoomHistory());
        }
      }

      async loadRoomHistory() {
        const container = document.getElementById('roomHistory');
        const items = document.getElementById('historyItems');

        if (!container || !items) {
          return;
        }

        let rooms = [];

        if (typeof this.storage?.getRooms === 'function') {
          try {
            rooms = await this.storage.getRooms();
          } catch (error) {
            console.warn('Unable to load room history.', error);
            rooms = [];
          }
        }

        if (rooms.length > 0) {
          container.style.display = 'block';
          items.innerHTML = rooms.map(room => `
            <div class="history-item" onclick="app.quickJoin('${room.id}')">
              <span class="history-room">${room.id}</span>
              <span class="history-time">${new Date(room.time).toLocaleDateString()}</span>
            </div>
          `).join('');
        } else {
          container.style.display = 'none';
          items.innerHTML = '';
        }
      }

      async persistRoom() {
        if (!this.roomId || typeof this.storage?.saveRoom !== 'function') {
          return;
        }

        try {
          await this.storage.saveRoom(this.roomId, { actorId: this.localUserId, title: this.roomId });
          await this.loadRoomHistory();
        } catch (error) {
          console.warn('Failed to save room history.', error);
        }
      }

      quickJoin(roomId) {
        document.getElementById('joinCode').value = roomId;
        this.showJoin();
      }

      // Utilities
      generateRoomId() {
        const segments = [];
        const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
        for (let i = 0; i < 3; i++) {
          let segment = '';
          for (let j = 0; j < 3; j++) {
            segment += chars[Math.floor(Math.random() * chars.length)];
          }
          segments.push(segment);
        }
        return segments.join('-');
      }

      copyRoomCode() {
        const code = document.getElementById('roomCode').textContent;
        if (code && code !== 'Loading...') {
          navigator.clipboard.writeText(code).then(() => {
            const elem = document.getElementById('roomCode');
            const original = elem.textContent;
            elem.textContent = '✅ Copied!';
            setTimeout(() => {
              elem.textContent = original;
            }, 2000);
          });
        }
      }

      updateStatus(text, type) {
        document.getElementById('statusText').textContent = text;
        const dot = document.getElementById('statusDot');
        dot.className = 'status-dot';
        if (type) dot.classList.add(type);
      }

      // Crypto
      async deriveKey(password) {
        const encoder = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey(
          'raw',
          encoder.encode(password),
          'PBKDF2',
          false,
          ['deriveBits', 'deriveKey']
        );

        return crypto.subtle.deriveKey(
          {
            name: 'PBKDF2',
            salt: encoder.encode('secure-p2p-chat-salt-v1'),
            iterations: 100000,
            hash: 'SHA-256'
          },
          keyMaterial,
          { name: 'AES-GCM', length: 256 },
          false,
          ['encrypt', 'decrypt']
        );
      }

      async encrypt(text) {
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encoded = new TextEncoder().encode(text);
        const encrypted = await crypto.subtle.encrypt(
          { name: 'AES-GCM', iv },
          this.cryptoKey,
          encoded
        );
        
        const combined = new Uint8Array(iv.length + encrypted.byteLength);
        combined.set(iv);
        combined.set(new Uint8Array(encrypted), iv.length);
        return combined;
      }

      async decrypt(data) {
        const iv = data.slice(0, 12);
        const encrypted = data.slice(12);
        
        try {
          const decrypted = await crypto.subtle.decrypt(
            { name: 'AES-GCM', iv },
            this.cryptoKey,
            encrypted
          );
          return new TextDecoder().decode(decrypted);
        } catch(e) {
          console.error('Decryption failed');
          return null;
        }
      }

      // Peer Connection
      async startHost() {
        const password = document.getElementById('hostPassword').value;
        if (!password) {
          alert('Please enter a password');
          return;
        }

        this.isHost = true;
        this.cryptoKey = await this.deriveKey(password);
        this.updateStatus('Creating room...', 'connecting');

        // Generate and display the share link
        const shareLink = this.generateShareLink(this.roomId, password);
        const shareLinkEl = document.getElementById('shareLink');
        if (shareLinkEl) {
          shareLinkEl.textContent = shareLink;
          shareLinkEl.dataset.link = shareLink;
        }
        document.getElementById('shareSection').style.display = 'block';
        this.currentShareLink = shareLink;
        this.setWaitingBanner(true, shareLink, 'Share this link with someone to start chatting.');
        this.showChat();

        this.initPeer(this.roomId);
      }

      async startJoin() {
        const roomId = document.getElementById('joinCode').value.trim();
        const password = document.getElementById('joinPassword').value;
        
        if (!roomId || !password) {
          alert('Please enter room code and password');
          return;
        }

        this.roomId = roomId;
        this.isHost = false;
        this.currentShareLink = '';
        this.cryptoKey = await this.deriveKey(password);
        this.updateStatus('Connecting...', 'connecting');
        this.setWaitingBanner(false, '');

        const joinerId = 'join-' + Math.random().toString(36).substr(2, 9);
        this.initPeer(joinerId);
      }

      initPeer(id) {
        if (this.peer) {
          this.peer.destroy();
        }

        this.peer = new Peer(id, {
          debug: 2,
          config: {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' }
            ]
          }
        });

        this.peer.on('open', async (peerId) => {
          console.log('Connected to signaling server with ID:', peerId);

          if (this.isHost) {
            this.updateStatus('Waiting for peer...', 'connecting');
            this.addSystemMessage(`Room created: ${this.roomId}`);
            this.addSystemMessage('Waiting for someone to join...');
            this.setWaitingBanner(true, this.currentShareLink, 'Waiting for someone to join...');

            await this.persistRoom();
          } else {
            const conn = this.peer.connect(this.roomId);
            this.setupConnection(conn);
          }
        });

        if (this.isHost) {
          this.peer.on('connection', (conn) => {
            console.log('Peer connecting');
            this.addSystemMessage('Peer is connecting...');
            this.updateStatus('Peer connecting...', 'connecting');
            this.setWaitingBanner(true, this.currentShareLink, 'Someone is connecting...');
            this.setupConnection(conn);
          });
        }

        this.peer.on('error', (err) => {
          console.error('Peer error:', err);

          if (err.type === 'peer-unavailable') {
            if (!this.isHost) {
              this.addSystemMessage('❌ Room not found. Make sure the room code is correct.');
              this.updateStatus('Error', '');
              setTimeout(() => this.showJoin(), 2000);
            }
          } else if (err.type === 'unavailable-id') {
            if (this.isHost) {
              this.roomId = this.generateRoomId();
              document.getElementById('roomCode').textContent = this.roomId;
              document.getElementById('currentRoom').textContent = this.roomId;

              const password = document.getElementById('hostPassword').value;
              if (password) {
                const shareLink = this.generateShareLink(this.roomId, password);
                const shareLinkEl = document.getElementById('shareLink');
                if (shareLinkEl) {
                  shareLinkEl.textContent = shareLink;
                  shareLinkEl.dataset.link = shareLink;
                }
                this.currentShareLink = shareLink;
                this.setWaitingBanner(true, shareLink, 'Share this link with someone to start chatting.');
              } else {
                this.currentShareLink = '';
                this.setWaitingBanner(false, '');
              }

              this.addSystemMessage(`Room ID was taken, new room: ${this.roomId}`);
              setTimeout(() => this.initPeer(this.roomId), 1000);
            }
          } else {
            this.addSystemMessage(`❌ Connection error: ${err.type}`);
            this.updateStatus('Error', '');
          }
        });
      }

      setupConnection(conn) {
        const activeConn = conn || this.conn;
        if (!activeConn) {
          console.warn('No connection available to set up.');
          return;
        }

        this.conn = activeConn;
        this.remoteUserId = activeConn.peer || 'peer';

        activeConn.on('open', async () => {
          console.log('Peer connection established');
          this.updateStatus('Connected', 'connected');
          this.addSystemMessage('✅ Secure connection established!');

          if (!this.isHost) {
            this.showChat();
          }

          if (this.isHost) {
            this.setWaitingBanner(false);
          }

          await this.persistRoom();

          if (typeof this.storage?.getMessages === 'function') {
            try {
              const messages = await this.storage.getMessages(this.roomId);
              messages.forEach((msg) => {
                this.displayMessage(msg.content, msg.type || 'them', msg.at);
              });
            } catch (error) {
              console.error('Failed to load stored messages:', error);
            }
          }
        });

        activeConn.on('data', async (data) => {
          const payload = data instanceof Uint8Array ? data : new Uint8Array(data);
          this.lastEncryptedHex = Array.from(payload)
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');
          const decrypted = await this.decrypt(payload);
          if (decrypted) {
            this.displayMessage(decrypted, 'them', Date.now(), payload);
            if (typeof this.storage?.recordMessage === 'function' && this.roomId) {
              this.storage.recordMessage({
                roomId: this.roomId,
                text: decrypted,
                type: 'them',
                actorId: this.remoteUserId || 'peer',
                userId: this.remoteUserId || 'peer'
              }).catch(error => console.warn('Failed to record incoming message.', error));
            }
          } else {
            this.addSystemMessage('⚠️ Failed to decrypt message');
          }
        });

        activeConn.on('close', () => {
          this.remoteUserId = null;
          if (this.isHost && this.currentShareLink) {
            this.updateStatus('Waiting for peer...', 'connecting');
            this.addSystemMessage('👋 Peer disconnected');
            this.setWaitingBanner(true, this.currentShareLink, 'Your guest disconnected. Share the link to invite someone else.');
          } else {
            this.updateStatus('Disconnected', '');
            this.addSystemMessage('👋 Peer disconnected');
          }
        });

        activeConn.on('error', (err) => {
          console.error('Connection error:', err);
          this.addSystemMessage('⚠️ Connection error occurred');
        });
      }

      // Messaging
      async sendMessage() {
        const input = document.getElementById('messageInput');
        const text = input.value.trim();

        if (!text || !this.conn) {
          return;
        }

        input.value = '';
        const timestamp = Date.now();

        let encrypted;
        try {
          encrypted = await this.encrypt(text);
        } catch (error) {
          console.error('Failed to encrypt message.', error);
          this.addSystemMessage('⚠️ Unable to encrypt message');
          return;
        }

        this.lastEncryptedHex = Array.from(encrypted)
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');

        this.displayMessage(text, 'me', timestamp, encrypted);

        if (typeof this.storage?.recordMessage === 'function' && this.roomId) {
          this.storage.recordMessage({
            roomId: this.roomId,
            text,
            type: 'me',
            actorId: this.localUserId,
            userId: this.localUserId
          }).catch(error => console.warn('Failed to record outgoing message.', error));
        }

        if (this.conn) {
          this.conn.send(encrypted);
        }
      }

      toggleEncryptedView() {
        this.showEncrypted = !this.showEncrypted;
        const toggle = document.getElementById('encryptedToggle');
        if (toggle) {
          toggle.classList.toggle('active', this.showEncrypted);
        }
        this.renderChatMessages();
      }

      renderChatMessages() {
        const container = document.getElementById('chatMessages');
        if (!container) {
          return;
        }

        container.innerHTML = '';

        this.messageLog.forEach((entry) => {
          let element = null;

          if (entry.kind === 'system') {
            element = this.createSystemMessageElement(entry);
          } else if (entry.kind === 'message') {
            if (this.showEncrypted) {
              element = entry.encrypted
                ? this.createEncryptedMessageElement(entry)
                : this.createEncryptedPlaceholderElement(entry);
            } else {
              element = this.createPlainMessageElement(entry);
            }
          }

          if (element) {
            container.appendChild(element);
          }
        });

        container.scrollTop = container.scrollHeight;
      }

      createPlainMessageElement(entry) {
        const { text, type, at } = entry;
        const message = document.createElement('div');
        message.className = `message ${type}`;

        const content = document.createElement('div');
        content.className = 'message-content';

        const textEl = document.createElement('div');
        textEl.className = 'message-text';
        textEl.textContent = text;

        const timeEl = document.createElement('div');
        timeEl.className = 'message-time';
        timeEl.textContent = this.formatTimestamp(at);

        content.appendChild(textEl);
        content.appendChild(timeEl);
        message.appendChild(content);

        return message;
      }

      createEncryptedMessageElement(entry) {
        const { encrypted, type, at } = entry;
        const payload = encrypted instanceof Uint8Array ? encrypted : this.toUint8Array(encrypted);

        if (!(payload instanceof Uint8Array) || payload.length === 0) {
          return this.createEncryptedPlaceholderElement(entry);
        }

        const message = document.createElement('div');
        message.className = `message ${type} encrypted-view`;

        const content = document.createElement('div');
        content.className = 'message-content';

        const wrapper = document.createElement('div');
        wrapper.className = 'encrypted-data';

        const iv = payload.slice(0, 12);
        const ciphertext = payload.slice(12);

        const ivLabel = document.createElement('div');
        ivLabel.className = 'data-label';
        ivLabel.textContent = `IV (${iv.length} bytes):`;

        const ivHex = document.createElement('div');
        ivHex.className = 'data-hex';
        const ivHexInfo = this.hexFromBytes(iv);
        ivHex.textContent = ivHexInfo.text || '—';

        const cipherLabel = document.createElement('div');
        cipherLabel.className = 'data-label';
        cipherLabel.textContent = 'Ciphertext:';

        const cipherHex = document.createElement('div');
        cipherHex.className = 'data-hex';
        const cipherHexInfo = this.hexFromBytes(ciphertext, 60);
        cipherHex.textContent = cipherHexInfo.text || '—';

        const info = document.createElement('div');
        info.className = 'data-info';
        const segments = [`Total: ${payload.length} bytes`];
        if (cipherHexInfo.truncated) {
          segments.push('Preview limited to first 60 bytes');
        }
        segments.push(this.formatTimestamp(at));
        info.textContent = segments.join(' • ');

        wrapper.appendChild(ivLabel);
        wrapper.appendChild(ivHex);
        wrapper.appendChild(cipherLabel);
        wrapper.appendChild(cipherHex);
        wrapper.appendChild(info);

        content.appendChild(wrapper);
        message.appendChild(content);

        return message;
      }

      createEncryptedPlaceholderElement(entry) {
        const { type, at } = entry;
        const message = document.createElement('div');
        message.className = `message ${type} encrypted-view`;

        const content = document.createElement('div');
        content.className = 'message-content';

        const wrapper = document.createElement('div');
        wrapper.className = 'encrypted-data';

        const label = document.createElement('div');
        label.className = 'data-label';
        label.textContent = 'Encrypted Payload';

        const details = document.createElement('div');
        details.className = 'data-hex';
        details.textContent = 'Unavailable (loaded from history)';

        const info = document.createElement('div');
        info.className = 'data-info';
        info.textContent = this.formatTimestamp(at);

        wrapper.appendChild(label);
        wrapper.appendChild(details);
        wrapper.appendChild(info);

        content.appendChild(wrapper);
        message.appendChild(content);

        return message;
      }

      createSystemMessageElement(entry) {
        const message = document.createElement('div');
        message.className = 'system-message';
        message.textContent = entry.text;
        return message;
      }

      formatTimestamp(at) {
        const value = typeof at === 'number' ? at : Date.now();
        return new Date(value).toLocaleTimeString([], {
          hour: '2-digit',
          minute: '2-digit'
        });
      }

      hexFromBytes(data, limit) {
        if (!(data instanceof Uint8Array)) {
          return { text: '', truncated: false };
        }

        const bytes = Array.from(data);
        const shouldLimit = typeof limit === 'number' && limit > 0;
        const truncated = shouldLimit && bytes.length > limit;
        const slice = shouldLimit ? bytes.slice(0, limit) : bytes;
        const text = slice.map(b => b.toString(16).padStart(2, '0')).join(' ');
        return {
          text: truncated ? `${text} ...` : text,
          truncated
        };
      }

      toUint8Array(data) {
        if (!data) {
          return null;
        }
        if (data instanceof Uint8Array) {
          return data.slice();
        }
        if (ArrayBuffer.isView(data) && data.buffer) {
          return new Uint8Array(data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength));
        }
        if (data instanceof ArrayBuffer) {
          return new Uint8Array(data);
        }
        return null;
      }

      displayMessage(text, type, at = Date.now(), encryptedData = null) {
        const entry = {
          kind: 'message',
          text: typeof text === 'string' ? text : '',
          type: type === 'me' ? 'me' : 'them',
          at: typeof at === 'number' ? at : Date.now(),
          encrypted: this.toUint8Array(encryptedData)
        };

        this.messageLog.push(entry);
        this.renderChatMessages();
      }

      addSystemMessage(text) {
        this.messageLog.push({
          kind: 'system',
          text,
          at: Date.now()
        });
        this.renderChatMessages();
      }

      async showSchemaView() {
        if (this.storage?.ready) {
          try {
            await this.storage.ready;
          } catch (error) {
            console.warn('Storage not ready for schema view.', error);
          }
        }

        let state = this.storage?.state;
        if (!(state instanceof ChatState)) {
          state = new ChatState();
        }

        let snapshot;
        try {
          snapshot = serializeState(state);
        } catch (error) {
          console.warn('Unable to serialize state snapshot.', error);
          snapshot = serializeState(new ChatState());
        }

        let recentEvents = [];
        if (typeof this.storage?.loadEventsAfter === 'function') {
          try {
            recentEvents = await this.storage.loadEventsAfter(Date.now() - 86400000);
          } catch (error) {
            console.warn('Unable to load recent events.', error);
            recentEvents = [];
          }
        }

        if (!Array.isArray(recentEvents)) {
          recentEvents = [];
        }

        recentEvents.sort((a, b) => (a.at || 0) - (b.at || 0));
        const timelineEvents = recentEvents.slice(-20);

        const existingModal = document.querySelector('.schema-modal');
        if (existingModal) {
          existingModal.remove();
        }

        const roomsCount = snapshot.rooms?.length || 0;
        const messagesCount = snapshot.messages?.length || 0;
        const eventsCount = recentEvents.length;

        const modal = document.createElement('div');
        modal.className = 'schema-modal';
        modal.innerHTML = `
          <div class="schema-content">
            <div class="schema-header">
              <h2>Data Architecture</h2>
              <button type="button" aria-label="Close schema view">✕</button>
            </div>
            <div class="schema-section">
              <h3>Event Log Structure</h3>
              <div class="schema-code">
                <pre>{
  id: "evt-xxxx",
  op: "MessagePosted" | "RoomCreated" | "UserJoined" | ...,
  payload: { /* operation-specific data */ },
  actor: "user-id",
  refs: ["room:xxx", "msg:xxx"],
  at: timestamp,
  semver: "1.0.0"
}</pre>
              </div>
            </div>
            <div class="schema-section">
              <h3>Current State Snapshot</h3>
              <div class="schema-tabs">
                <button class="tab-btn active" data-tab="schema-rooms">Rooms (${roomsCount})</button>
                <button class="tab-btn" data-tab="schema-messages">Messages (${messagesCount})</button>
                <button class="tab-btn" data-tab="schema-events">Events (${eventsCount})</button>
              </div>
              <div id="schema-rooms" class="tab-content active"><pre></pre></div>
              <div id="schema-messages" class="tab-content"><pre></pre></div>
              <div id="schema-events" class="tab-content"><div class="events-timeline"></div></div>
            </div>
            <div class="schema-section">
              <h3>Storage Layers</h3>
              <div class="storage-diagram">
                <div class="storage-layer">
                  <strong>IndexedDB Stores:</strong>
                  <ul>
                    <li>events: All domain events (append-only log)</li>
                    <li>snapshots: Periodic state snapshots</li>
                    <li>blobs: Binary attachments (future)</li>
                  </ul>
                </div>
                <div class="storage-layer">
                  <strong>In-Memory State (ChatState):</strong>
                  <ul>
                    <li>rooms: Map&lt;roomId, RoomData&gt;</li>
                    <li>messages: Map&lt;messageId, Message&gt;</li>
                    <li>byRoom: Map&lt;roomId, messageId[]&gt;</li>
                    <li>reactions: Map&lt;messageId, Map&lt;emoji, Set&lt;userId&gt;&gt;&gt;</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="schema-section">
              <h3>Encryption Details</h3>
              <div class="schema-code">
                <pre>Key Derivation: PBKDF2 (100,000 iterations, SHA-256)
Encryption: AES-GCM (256-bit key)
Message Format: [IV (12 bytes)][Ciphertext (variable)]
Current Key: ${this.cryptoKey ? 'Loaded ✓' : 'Not set ✗'}</pre>
              </div>
            </div>
          </div>
        `;

        const roomsPre = modal.querySelector('#schema-rooms pre');
        if (roomsPre) {
          roomsPre.textContent = JSON.stringify(snapshot.rooms || [], null, 2);
        }

        const messagesPre = modal.querySelector('#schema-messages pre');
        if (messagesPre) {
          const recentMessages = Array.isArray(snapshot.messages)
            ? snapshot.messages.slice(-10)
            : [];
          messagesPre.textContent = JSON.stringify(recentMessages, null, 2);
        }

        const eventsTimeline = modal.querySelector('#schema-events .events-timeline');
        if (eventsTimeline) {
          if (timelineEvents.length === 0) {
            const empty = document.createElement('div');
            empty.className = 'event-item';
            empty.textContent = 'No events captured in the last 24 hours.';
            eventsTimeline.appendChild(empty);
          } else {
            timelineEvents.forEach((event) => {
              const item = document.createElement('div');
              item.className = 'event-item';

              const op = document.createElement('div');
              op.className = 'event-op';
              op.textContent = event.op || 'Unknown Event';

              const details = document.createElement('div');
              details.className = 'event-details';

              const idSpan = document.createElement('span');
              idSpan.className = 'event-id';
              idSpan.textContent = event.id || '—';

              const timeSpan = document.createElement('span');
              timeSpan.className = 'event-time';
              timeSpan.textContent = new Date(event.at || Date.now()).toLocaleString();

              details.appendChild(idSpan);
              details.appendChild(timeSpan);

              const payload = document.createElement('div');
              payload.className = 'event-payload';
              payload.textContent = JSON.stringify(event.payload ?? {}, null, 2);

              item.appendChild(op);
              item.appendChild(details);
              item.appendChild(payload);

              eventsTimeline.appendChild(item);
            });
          }
        }

        const closeBtn = modal.querySelector('.schema-header button');
        if (closeBtn) {
          closeBtn.addEventListener('click', () => modal.remove());
        }

        modal.addEventListener('click', (event) => {
          if (event.target === modal) {
            modal.remove();
          }
        });

        modal.querySelectorAll('.tab-btn').forEach((btn) => {
          btn.addEventListener('click', () => {
            modal.querySelectorAll('.tab-btn').forEach((b) => b.classList.remove('active'));
            modal.querySelectorAll('.tab-content').forEach((content) => content.classList.remove('active'));
            btn.classList.add('active');
            const target = modal.querySelector(`#${btn.dataset.tab}`);
            if (target) {
              target.classList.add('active');
            }
          });
        });

        document.body.appendChild(modal);
      }

      // Disconnect
      disconnect() {
        const activeRoom = this.roomId;
        if (activeRoom && typeof this.storage?.leaveRoom === 'function') {
          this.storage.leaveRoom(activeRoom, { actorId: this.localUserId })
            .catch(error => console.warn('Failed to record room leave.', error));
        }

        this.setWaitingBanner(false, '', 'Share the invite link below to bring someone into this secure room.');
        this.currentShareLink = '';
        this.isHost = false;

        const shareLinkEl = document.getElementById('shareLink');
        if (shareLinkEl) {
          shareLinkEl.textContent = 'Generating link...';
          delete shareLinkEl.dataset.link;
        }

        const shareSection = document.getElementById('shareSection');
        if (shareSection) {
          shareSection.style.display = 'none';
        }

        if (this.conn) this.conn.close();
        if (this.peer) this.peer.destroy();

        this.conn = null;
        this.peer = null;
        this.cryptoKey = null;
        this.roomId = null;
        this.remoteUserId = null;
        this.messageLog = [];
        this.showEncrypted = false;
        this.lastEncryptedHex = '';
        this.renderChatMessages();

        const encryptedToggle = document.getElementById('encryptedToggle');
        if (encryptedToggle) {
          encryptedToggle.classList.remove('active');
        }

        document.getElementById('hostPassword').value = '';
        document.getElementById('joinPassword').value = '';
        document.getElementById('joinCode').value = '';

        this.updateStatus('Disconnected', '');
        this.showWelcome();
      }
    }

    // Initialize app
    const app = new SecureChat();

    // Service Worker (if you have one)
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').catch(err => {
        console.log('Service worker registration failed:', err);
      });
    }
  </script>
</body>
</html>
